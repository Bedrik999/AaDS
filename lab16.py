class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def parse_tree_string(tree_str):
    # Парсит строку в линейно-скобочной записи и строит бинарное дерево
    
    def parse_subtree(s, index): #объявляем вложенную функцию для рекурсивного разбора
        if index >= len(s) or s[index] == ',' or s[index] == ')': # проверяем, не вышли ли за границы строки,или текущий символ - запятая, или текущий символ - закрывающая скобка
            return None, index # возвращаем пустой узел и текущую позицию
        
        # Извлекаем значение узла
        value_str = '' # создаем пустую строку для накопления цифр
        while index < len(s) and s[index].isdigit(): # цикл пока не конец строки и символ является цифрой    
            value_str += s[index]
            index += 1
        
        if not value_str: # если не нашли цифр 
            return None, index # возвращаем пустой узел
        
        node = TreeNode(int(value_str)) #создаем новый объект-узел
        
        # Если следующий символ '(', значит есть дети
        if index < len(s) and s[index] == '(': # Проверяем, есть ли следующий символ и является ли он открывающей скобкой
            node.left, index = parse_subtree(s, index + 1)  # рекурсивно разбираем левое поддерево (пропускаем '(')
            
            if index < len(s) and s[index] == ',': # Проверяем, есть ли запятая между детьми
                index += 1 # пропускаем запятую
            
            node.right, index = parse_subtree(s, index) #  рекурсивно разбираем правое поддерево,  сохраняем правого потомка и обновляем позицию
            
            if index < len(s) and s[index] == ')': # Проверяем закрывающую скобку
                index += 1
        
        return node, index # Возвращаем созданный узел и текущую позицию
    
    root, _ = parse_subtree(tree_str, 0) # запускаем разбор с позиции 0
    return root # возвращаем корневой узел

def iterative_preorder_traversal(root):
    
    if root is None: # проверяем, не пустое ли дерево
        return ""
    
    stack = []          # Создаем пустой стек
    result = []         # создаем список для хранения значений узлов в порядке обхода
    current = root      # сохраняем корневой узел в переменную current
    
    # Помещаем корневой узел в стек
    stack.append(current)
    
    # Пока стек не пуст, продолжаем обход
    while stack:
        # ИЗВЛЕКАЕМ ВЕРХНИЙ ЭЛЕМЕНТ СТЕКА 
        current = stack.pop()
        # pop() удаляет и возвращает последний элемент стека 
        
        # ДОБАВЛЯЕМ ЗНАЧЕНИЕ ТЕКУЩЕГО УЗЛА В РЕЗУЛЬТАТ 
        result.append(str(current.value))
        
        # ВАЖНО: сначала добавляем ПРАВОГО потомка, потом ЛЕВОГО 
        # Это нужно потому что стек работает по принципу LIFO 
        # и мы хотим сначала обработать левого потомка
        
        # Если существует правый потомок - добавляем его в стек
        if current.right is not None:
            stack.append(current.right)
        
        # Если существует левый потомок - добавляем его в стек
        if current.left is not None:
            stack.append(current.left)
    
    # ↓↓↓ ПРЕОБРАЗУЕМ СПИСОК В СТРОКУ ЧЕРЕЗ ПРОБЕЛЫ ↓↓↓
    return " ".join(result)


def main():
    # Входная строка в линейно-скобочной записи
    tree_string = "8(3(1,6(4,7)),10(,14(13,)))"
    
    print("Входная строка:", tree_string)
    print("\nСтруктура дерева:")
    
    # Парсим строку и строим дерево
    root = parse_tree_string(tree_string)

    # Выполняем нерекурсивный прямой обход
    print("\nРезультаты обхода:")
    
    preorder_result = iterative_preorder_traversal(root)
    print(f"Нерекурсивный прямой обход: {preorder_result}")

if __name__ == "__main__":
    main()

'''
Стек: [8]
Текущий: None
Результат: []
    8
   / \
  3   10

Стек: []               ← 8 извлечен
Текущий: 8 ✓          ← Обрабатываем
Результат: ["8"]      ← Добавили

Стек: [10, 3]         ← 3 добавлен последним (извлечется первым)
Текущий: 8 ✓
Результат: ["8"]
    8 ✓
   / \
  3   10

Стек: [10]             ← 3 извлечен
Текущий: 3 ✓          ← Обрабатываем
Результат: ["8", "3"]
    8 ✓
   / \
  3 ✓  10

Стек: [10, 6, 1]      ← 1 добавлен последним
Текущий: 3 ✓
Результат: ["8", "3"]
    8 ✓
   / \
  3 ✓  10
 / \
1   6

Стек: [10, 6]          ← 1 извлечен
Текущий: 1 ✓          ← Обрабатываем
Результат: ["8", "3", "1"]
    8 ✓
   / \
  3 ✓  10
 / \
1 ✓  6

Стек: [10]             ← 6 извлечен
Текущий: 6 ✓          ← Обрабатываем
Результат: ["8", "3", "1", "6"]
    8 ✓
   / \
  3 ✓  10
 / \
1 ✓  6 ✓

Стек: [10, 7, 4]      ← 4 добавлен последним
Текущий: 6 ✓
Результат: ["8", "3", "1", "6"]
    8 ✓
   / \
  3 ✓  10
 / \
1 ✓  6 ✓
   / \
  4   7

Стек: [10, 7]          ← 4 извлечен
Текущий: 4 ✓          ← Обрабатываем
Результат: ["8", "3", "1", "6", "4"]
    8 ✓
   / \
  3 ✓  10
 / \
1 ✓  6 ✓
   / \
  4 ✓  7

Стек: [10]             ← 7 извлечен
Текущий: 7 ✓          ← Обрабатываем
Результат: ["8", "3", "1", "6", "4", "7"]
    8 ✓
   / \
  3 ✓  10
 / \
1 ✓  6 ✓
   / \
  4 ✓  7 ✓

Стек: []               ← 10 извлечен
Текущий: 10 ✓         ← Обрабатываем
Результат: ["8", "3", "1", "6", "4", "7", "10"]
    8 ✓
   / \
  3 ✓  10 ✓

Стек: [14]             ← Только 14 добавлен
Текущий: 10 ✓
Результат: ["8", "3", "1", "6", "4", "7", "10"]
    8 ✓
   / \
  3 ✓  10 ✓
         \
          14

Стек: []               ← 14 извлечен
Текущий: 14 ✓         ← Обрабатываем
Результат: ["8", "3", "1", "6", "4", "7", "10", "14"]
    8 ✓
   / \
  3 ✓  10 ✓
         \
          14 ✓

Стек: [13]             ← 13 добавлен
Текущий: 14 ✓
Результат: ["8", "3", "1", "6", "4", "7", "10", "14"]
    8 ✓
   / \
  3 ✓  10 ✓
         \
          14 ✓
           /
          13

Стек: []               ← 13 извлечен
Текущий: 13 ✓         ← Обрабатываем
Результат: ["8", "3", "1", "6", "4", "7", "10", "14", "13"]
    8 ✓
   / \
  3 ✓  10 ✓
         \
          14 ✓
           /
          13 ✓
        
"8 3 1 6 4 7 10 14 13"

'''
