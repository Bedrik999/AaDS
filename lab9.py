#Пирамидальная сортировка (heap sort).
def heapify(arr, n, i): #i - индекс узла, от которого начинаем "просеивание вниз
    # n - размер текущей кучи (может быть меньше длины массива)
    
    largest = i          # предполагаем, что текущий узел (корень поддерева) - наибольший
    left = 2 * i + 1     # вычисляем индекс левого потомка
    right = 2 * i + 2    # вычисляем индекс правого потомка

    # Если левый потомок существует и больше корня
    if left < n and arr[left] > arr[largest]:
        #left < n - проверяем, существует ли левый потомок (не выходит за границы кучи)
        #arr[left] > arr[largest] - если левый потомок больше текущего наибольшего
        largest = left

    # Если правый потомок существует и больше текущего наибольшего
    if right < n and arr[right] > arr[largest]:
        largest = right

    # Если наибольший элемент не корень
    if largest != i: # если наибольший элемент оказался не в корне
        arr[i], arr[largest] = arr[largest], arr[i]  # Меняем местами
        # Рекурсивно преобразуем затронутое поддерево
        heapify(arr, n, largest) # рекурсивно вызываем heapify для поддерева, куда переместили меньший элемент


def heap_sort(arr):
    
    n = len(arr)
    
    # Шаг 1: Построение максимальной кучи
    # Проходим от последнего нелистового узла до корня
    for i in range(n // 2 - 1, -1, -1): # находим индекс последнего нелистового узла
        heapify(arr, n, i) # Для каждого узла вызываем heapify
    #Листовые узлы уже удовлетворяют свойству кучи (у них нет потомков)
    #Поэтому достаточно обработать только нелистовые узлы
    # Шаг 2: Извлекаем элементы из кучи один за другим
    for i in range(n - 1, 0, -1):
        # Перемещаем текущий корень (максимальный элемент) в конец
        arr[i], arr[0] = arr[0], arr[i]
        # Вызываем heapify для уменьшенной кучи
        heapify(arr, i, 0) #восстанавливаем свойство кучи для уменьшенной кучи
    
    return arr


# Пример использования
data = [329, 457, 657, 839, 436, 720, 355]
print("Исходный массив:", data)
sorted_data = heap_sort(data.copy())  # Используем copy() чтобы не изменять исходный массив
print("Отсортированный массив:", sorted_data)

# Дополнительный пример для демонстрации работы
small_data = [4, 10, 3, 5, 1]
print("Демонстрация на маленьком массиве:")
print("Исходный массив:", small_data)
print("Отсортированный массив:", heap_sort(small_data.copy()))
'''
Исходное поддерево: [3, 10, 7]  где 3 - корень (i=0)
    3
   / \
  10  7

1. largest = 0 (3)
2. left = 1 (10) > 3 -> largest = 1
3. right = 2 (7) < 10 -> largest остается 1
4. Меняем 3 и 10 местами
5. Рекурсивно вызываем heapify для поддерева с корнем 3

Результат: [10, 3, 7]
    10
   /  \
  3    7
'''
'''
Исходный массив: [4, 10, 3, 5, 1]
Соответствующее дерево:
       4
      / \
     10  3
    / \
   5   1

Шаги построения:
1. i = 1 (узел 10): heapify -> [4, 10, 3, 5, 1] (без изменений)
2. i = 0 (узел 4): heapify -> [10, 4, 3, 5, 1] -> [10, 5, 3, 4, 1]

Итоговая куча:
       10
      /  \
     5    3
    / \
   4   1
'''

'''
ШАГ 1: ПОСТРОЕНИЕ КУЧИ
[4, 10, 3, 5, 1] -> [10, 5, 3, 4, 1]

       4             10
      / \           /  \
     10  3   ->    5    3
    / \           / \
   5   1         4   1

ШАГ 2: ИЗВЛЕЧЕНИЕ
1. [10, 5, 3, 4, 1] -> [1, 5, 3, 4, 10] -> [5, 4, 3, 1, 10]
2. [5, 4, 3, 1, 10] -> [1, 4, 3, 5, 10] -> [4, 1, 3, 5, 10]
3. [4, 1, 3, 5, 10] -> [3, 1, 4, 5, 10] -> [3, 1, 4, 5, 10]
4. [3, 1, 4, 5, 10] -> [1, 3, 4, 5, 10]

РЕЗУЛЬТАТ: [1, 3, 4, 5, 10]
'''